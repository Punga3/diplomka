\chapter*{Preliminaries}
\addcontentsline{toc}{chapter}{Preliminaries}

In this chapter we recall a few important notions which we will use in the next chapter to define the central construction we study. We do not review the notions formally but always provide a reference for the reader unfamiliar with these topics. Throughout this thesis we assume a basic knowledge of mathematical logic, model theory and measure theory. Important concepts for us are the nonstandard models of true arithmetic, nonstandard analysis and $\NP$ search problems. We discuss these in more detail in the rest of this chapter.

\section*{The ambient model $\M$}
\addcontentsline{toc}{section}{The ambient model $\M$}

Let $L_{all}$ be the language consisting of function symbols for all functions on $\N$, all relations and all constants. We call a model of $\Th_{L_{all}}(\N)$ nonstandard if it is not isomorphic to $\N$. Every model of $\Th(\N)$ contains an initial segment isomorphic to $\N$ so we can view nonstandard models as those which also contain `infinite natural numbers', if we assume $\M\models \Th(\N)$ contains $\N$ as an initial segment then the elements $\M\setminus \N$ are called nonstandard. We recommend the introduction of \cite{kaye1991pa} for a review of this topic. In the appendix of \cite{krajicek2010forcing} there is an explict ultraproduct construction of a model $\M\models \Th(\N)$ which is $\aleph_1$-saturated.

This $\aleph_1$-saturated model $\M$ is used throughout this thesis and we call it the ambient model of arithmetic. For our applications we only need to know that the model is nonstandard and the following property holds because of the $\aleph_1$-saturation. (Note that we can encode finite sequences and sets in $\M$ which lets us state the property.)

\begin{prope}
If $\{a_k\}_{k\geq 0}$ is a sequence with elements in $\N$ then there is an element $t\in \M \setminus \N$ and a sequence $\{b_k\}_{k<t}\in \M$ with $a_k=b_k$ for all $k\in \N$.
\end{prope}

By overspill in $\M$ if some definable property $P$ holds for $a_k$ with unbounded indexes, then there is also some nonstandard $n<t$ such that $b_s$ satisfies the property $P$. Moreover, if some definable property $P$ holds for all $b_k$ with $k$ above some $k_0$ it has to also hold by induction in $\M$ for all nonstandard $b_n$. These $b_n$ are intuitively the limit elements of the sequence $\{a_k\}_{k\geq0}$.

Now let us introduce some notation. For $m\in\M$ we denote the set of numbers below $m$ as $\set{m}:=\{0,\dots,m-1\}\in\M$ and $\abs{m}$ as the bit-length of the (possibly-nonstandard) number $m$. These definitions can be easily made rigorous using the first order definitions of these functions.

\section*{Nonstandard analysis}
\addcontentsline{toc}{section}{Nonstandard analysis}

The reader can refer to \cite{goldbring2014lecture} for more formal treatment of topics discussed in this section including proofs. To use the method of forcing with random variables we need to consider the concept of $\M$-rationals. To define them we start by simply adjoining all negative elements to the semiring $\M$ to obtain the integral domain $\overline \M$. $\M$-rationals are then simply the ordered field of fractions $\Frac(\overline \M)$ which we denote $\Q^\M$.

There is a canonical injection $\Q \xhookrightarrow{} \Q^\M$ whose image consists exactly of the `standard fractions'. We call a $q\in\Q^\M$ finite if there is a standard $k$ such that $\abs{q}<\frac{k}{1}$, otherwise we call it infinite. We call $q\in\Q^\M$ infinitesimal if $q^{-1}$ is infinite (see also Definition \ref{defiinfinitesimal}). We will use $\Q^\M$ in a similar manner to what is called hyperreal numbers which lets us use it as an alternative foundation for the concepts of real analysis. The following is an important result which we use throughout the thesis.

\begin{thrm*}
There is a surjective function from the ring of finite $\M$-rationals to $\R$ which is a homomorphism of rings and the kernel is the ideal of infinitesimal numbers.

We denote the function $\st(-)$ and call it the \textbf{standard part of the $\M$-rational}.
\end{thrm*}

The following result characterizes convergence of a sequence of rational numbers in the language of nonstandard analysis.

\begin{thrm*}
Let $\{c_k\}_{k\geq 0}$ be a sequence of rational numbers and let $\{\tilde c_k\}_{t\geq k}$ be its nonstandard prolongation in $\M$. Then \[\lim_{k\to\infty}c_k = r \in \R\]
if and only if for any nonstandard $n\leq t$ we have that
$\st(\tilde c_n)=r.$
\end{thrm*}

We close this section with two inequalities heavily used in the proofs throughout the thesis.

\begin{thrm*}[Bernoulli's inequality]
Let $y \in \M$ and $x\in \Q^\M, x\geq -1$, then
\[(1+x)^y \geq 1+yx.\]
\end{thrm*}

\begin{thrm*}[Exponential inequality]
Let $y \in \M$, $x\in \Q^\M, x\geq 0$ and $x\leq y$, then
\[\left(1-\frac{x}{y}\right)^y \leq e^{-x}.\]
\end{thrm*}

\section*{Total $\NP$ search problems and polynomial oracle time}
\addcontentsline{toc}{section}{Total $\NP$ search problems and polynomial oracle time}

Our goal is to tie the properties of the wide limit with some complexity theoretic statements. We will recall several notions used later on.

The class of total $\NP$ search problems $\TFNP$, first defined in \cite{megiddo1991total}, consist of all relations on binary strings $P(x,y)$ such that: a) There is a polynomial time machine $M$ which, given $x,y$, can decide whether $P(x,y)$ holds. b) There exists a constant $c>0$ and for every $x$ there exists at least one $y$ satisfying $\abs{y}\leq \abs{x}^c$ such that $P(x,y)$ holds.

While the definition of the class $\TFNP$ seems natural, the inner structure looks more arbitrary and the class is generally studied through its semantic subclasses. For example it is conjectured that there is no complete problem for $\TFNP$ \cite{goldberg2018tfnp} for a suitable notion of reducibility.

Various subclasses are defined as all problems reducible to some problem corresponding usually to a combinatorial lemma, for some appropriate definition of reduction. Two main subclasses are relevant for us. The class $\PPA$, polynomial parity argument, corresponds to all problems reducible to $\LEAF$, the problem formulated as follows. An instance is given by a number $k$ and a graph $G$ on the vertex set $\set{2^{\abs{k}}}$, presented by a Boolean circuit of polynomial size in $\abs{k}$ computing its neighbourhood function, such that $\deg_G(0)=1$ and $\forall v: \deg_G(v)\leq 2$. The task is then to find some nonzero $v$ with $\deg_G(v)=1$. The corresponding combinatorial principle being the handshaking lemma, which assures the problem is total.

The other class $\PPAD$, directed polynomial parity argument, with the complete problem $\SOURCEORSINK$ is formulated as follows. An instance is given by a number $k$ and a directed graph $G$ on the vertex set $\set{2^{\abs{k}}}$, presented by a Boolean circuit of polynomial size in $\abs{k}$ computing the neighbourhood function, such that the vertex $0$ is a source and $\forall v: \deg_G^+(v),\deg_G^-(v)\leq 1$. The task is to find some nonzero vertex $v$ which is a source or a sink. The corresponding combinatorial principle here being the directed version of the handshaking lemma.

So far, we presented what is called `type 1' problem in \cite{beame1995rel}. The ones we are interested in are `type 2' problems which replace the input graph $G$ with a pair $(\alpha,x)$ consisting of an oracle $\alpha$ describing the neighbourhood function $N_G(-)$ (or both $N_G^+(-)$ and $N_G^-(-)$ in the directed case) on binary string of length at most $\abs{x}$. While the goal to solve these problems remains the same, suddenly the situation is quite different -- these type 2 classes can be easily separated from $\FP^2$, the type 2 version of polynomial time functions, by an adversary argument. More importantly we have that $\PPAD\subsetneq \PPA$ as type 2 complexity classes. Intuitively one can forget the orientation to get the undirected version, but cannot consistently assign orientation to undirected edges of a large graph.

The traditional model of computation is the Turing machines and for the type 2 problems the oracle Turing machine. But to prove separations in the type 2 case, we can abstract the computation of an oracle Turing machine into a decision tree which describes the queries to an oracle. This abstraction is what to keep in mind in the following chapter when we define the class of functions $F_{rud}$.
